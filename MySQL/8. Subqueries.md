# 1. **Introduction to Subqueries:**

# Definition and Purpose of Subqueries:

## 1. **Definition:**
   - A subquery is a SQL query embedded within another query, allowing the results of the inner query to be used in the outer query.
   - It is enclosed in parentheses and generally placed within different parts of a SQL statement.

## 2. **Purpose:**
   - **Data Retrieval:** Subqueries can be used to retrieve data that will be used by the main query to filter, compare, or perform calculations.
  
   - **Comparison Operations:** Subqueries are often employed in comparison operations, such as finding values greater than, less than, or equal to a result obtained from a subquery.

   - **IN and NOT IN Operators:** Subqueries are frequently used with the `IN` and `NOT IN` operators to filter results based on a set of values returned by the subquery.

   - **Existence Checks:** Subqueries are used for checking the existence of records in a subquery result, often combined with the `EXISTS` or `NOT EXISTS` keywords.

   - **Aggregation and Grouping:** Subqueries can be used to perform aggregate functions or grouping operations on a subset of data before incorporating the results into the main query.

   - **Correlated Subqueries:** These are subqueries that refer to columns from the outer query, allowing for more complex and context-dependent filtering.

   - **Logical Conditions:** Subqueries are employed in logical conditions within WHERE or HAVING clauses, contributing to the overall criteria for selecting or aggregating data.

### Example:
Consider a scenario where you want to find all employees whose salaries are above the average salary for their department. The average salary is calculated using a subquery:

```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees WHERE department_id = employees.department_id);
```

In this example, the subquery calculates the average salary for each department, and the main query retrieves employees whose salary exceeds the calculated average for their respective departments.

# 2. **Scalar Subqueries:**
## Understanding scalar subqueries.
A scalar subquery is a type of subquery in SQL that returns a single value, typically a single column from a single row. Scalar subqueries are used to retrieve a specific piece of information that can be compared, used in calculations, or included in the result set of the main query.

### Characteristics of Scalar Subqueries:

1. **Returns Single Value:**
   - Scalar subqueries always return a single value. This value can be a numeric value, string, date, or any other data type supported by the database.

2. **Used in Comparison:**
   - Scalar subqueries are commonly used in situations where you need to compare a single value with other values in the main query.

3. **Commonly Used in WHERE Clause:**
   - Scalar subqueries are often found in the WHERE clause of a query, specifying a condition based on the result of the subquery.

### Example:

Consider the following example where you want to retrieve the names of employees whose salary is greater than the average salary for the entire company:

```sql
SELECT employee_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

In this example:
- The scalar subquery `(SELECT AVG(salary) FROM employees)` returns a single value, which is the average salary for all employees.
- The main query then selects employees whose individual salaries are greater than the average obtained from the scalar subquery.

### Common Use Cases:

1. **Comparisons:**
   - Scalar subqueries are frequently used in comparisons to filter rows based on specific conditions.

2. **Calculations:**
   - Scalar subqueries can be used in mathematical expressions or calculations within the main query.

3. **Conditional Logic:**
   - They are useful in scenarios where you need to apply conditional logic based on a single value.

### Syntax:

The general syntax for a scalar subquery in a WHERE clause is as follows:

```sql
SELECT column1, column2, ...
FROM table_name
WHERE column_name comparison_operator (SELECT scalar_value FROM another_table);
```

## Using scalar subqueries in SELECT statements.
Scalar subqueries can be used in the SELECT statement to retrieve a single value from another table or subquery and include that value as part of the result set. Here's an example demonstrating the use of a scalar subquery in a SELECT statement:

Consider a scenario where you want to retrieve a list of employees along with their salary and the average salary for their respective departments:

```sql
SELECT
  employee_id,
  employee_name,
  salary,
  (SELECT AVG(salary) FROM employees WHERE department_id = main. department_id) AS avg_department_salary
FROM
  employees main;
```

In this example:

- The main query retrieves employee details from the `employees` table.
- The scalar subquery `(SELECT AVG(salary) FROM employees WHERE department_id = main.department_id)` calculates the average salary for the current department of each employee in the main query. It is aliased as `avg_department_salary`.
- The main query includes the calculated average salary as part of the result set.

Here's a breakdown of the SQL components:

- **SELECT Clause:**
  - `employee_id`, `employee_name`, and `salary` are selected from the `employees` table.
  - The scalar subquery `(SELECT AVG(salary) FROM employees WHERE department_id = main.department_id)` retrieves the average salary for the current department and is aliased as `avg_department_salary`.

- **FROM Clause:**
  - `FROM employees main` specifies the source table as `employees` and aliases it as `main`.

- **Result Set:**
  - The result set includes columns from the main query (`employee_id`, `employee_name`, `salary`) and the additional column `avg_department_salary` calculated by the scalar subquery.

This example demonstrates how scalar subqueries in the SELECT statement can be used to dynamically calculate values based on conditions or data from the same or related tables.
## Examples and practical applications.

### Example 1: Retrieve Employee Details with Department Names

```sql
SELECT
  employee_id,
  employee_name,
  salary,
  (SELECT department_name FROM departments WHERE department_id = employees.department_id) AS department_name
FROM
  employees;
```

**Application:**
- This query retrieves employee details along with their department names.
- The scalar subquery fetches the department name based on the `department_id` in the main query.

### Example 2: Display Products with Price Differences

```sql
SELECT
  product_id,
  product_name,
  price,
  (SELECT MAX(price) FROM products) - price AS price_difference
FROM
  products;
```

**Application:**
- This query displays products along with the price difference between each product's price and the maximum price in the entire product list.
- The scalar subquery calculates the maximum price from the `products` table.

### Example 3: Get Customer Orders with Total Amount

```sql
SELECT
  order_id,
  customer_id,
  order_date,
  (SELECT SUM(quantity * unit_price) FROM order_items WHERE order_id = orders.order_id) AS total_amount
FROM
  orders;
```

**Application:**
- This query retrieves customer orders along with the total amount for each order.
- The scalar subquery calculates the total amount by summing the product of quantity and unit price for each item in the order.

### Example 4: Find Students with Higher Scores

```sql
SELECT
  student_id,
  student_name,
  score,
  (SELECT AVG(score) FROM student_scores WHERE subject = main.subject) AS avg_subject_score
FROM
  student_scores main;
```

**Application:**
- This query displays student scores along with the average score for the corresponding subject.
- The scalar subquery calculates the average score based on the subject in the main query.

### Example 5: Retrieve Customer Details with Latest Order Date

```sql
SELECT
  customer_id,
  customer_name,
  (SELECT MAX(order_date) FROM orders WHERE customer_id = customers.customer_id) AS latest_order_date
FROM
  customers;
```

**Application:**
- This query fetches customer details along with the latest order date for each customer.
- The scalar subquery retrieves the maximum order date based on the customer_id in the main query.

# 3. **Row Subqueries:**
## Exploring row subqueries.
Row subqueries, also known as row expressions or table subqueries, return multiple rows and columns as a result. They are often used in scenarios where you need to compare entire rows or sets of values. Let's explore some examples and practical applications of row subqueries:

### Example 1: Find Employees with the Same Job Title in Another Department

```sql
SELECT employee_id, employee_name, job_title, department_id
FROM employees
WHERE (job_title, department_id) IN (SELECT job_title, department_id FROM employees WHERE employee_id = 101);
```

**Application:**
- This query retrieves employees who share the same job title and department as the employee with `employee_id` 101.
- The row subquery `(SELECT job_title, department_id FROM employees WHERE employee_id = 101)` returns a set of values for job title and department, and the main query compares it using the `IN` operator.

### Example 2: Display Orders with the Same Products

```sql
SELECT order_id, product_id, quantity
FROM order_items
WHERE (order_id, product_id) IN (SELECT order_id, product_id FROM order_items WHERE quantity > 5);
```

**Application:**
- This query shows orders with products where the quantity is greater than 5.
- The row subquery `(SELECT order_id, product_id FROM order_items WHERE quantity > 5)` returns a set of order_id and product_id pairs, and the main query filters based on the `IN` condition.

### Example 3: Retrieve Customers with Multiple Orders

```sql
SELECT customer_id, customer_name
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(order_id) > 1);
```

**Application:**
- This query fetches customers who have placed multiple orders.
- The row subquery `(SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(order_id) > 1)` returns a list of customer_ids with more than one order, and the main query filters based on the `IN` condition.

### Example 4: Get Employees with Higher Salaries in the Same Department

```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees
WHERE (salary, department_id) > (SELECT AVG(salary), department_id FROM employees GROUP BY department_id HAVING department_id = employees.department_id);
```

**Application:**
- This query retrieves employees whose salary is higher than the average salary in their respective departments.
- The row subquery `(SELECT AVG(salary), department_id FROM employees GROUP BY department_id HAVING department_id = employees.department_id)` returns the average salary and department_id pairs, and the main query compares them using the `>` operator.

### Example 5: Find Products with Similar Characteristics

```sql
SELECT product_id, product_name, category
FROM products
WHERE (price, weight, color) = (SELECT price, weight, color FROM products WHERE product_id = 101);
```

**Application:**
- This query finds products with similar characteristics (price, weight, and color) as the product with `product_id` 101.
- The row subquery `(SELECT price, weight, color FROM products WHERE product_id = 101)` returns a set of values for the specified product, and the main query compares them using the `=` operator.
## Implementing row subqueries in SELECT statements.
Let's go through some examples to illustrate how to implement row subqueries in SELECT statements.

### Example 1: Retrieve Employees with the Same Job Title in Another Department

```sql
SELECT employee_id, employee_name, job_title, department_id
FROM employees
WHERE (job_title, department_id) IN (
  SELECT job_title, department_id
  FROM employees
  WHERE employee_id = 101
);
```

**Explanation:**
- This query retrieves employees who share the same job title and department as the employee with `employee_id` 101.
- The row subquery `(SELECT job_title, department_id FROM employees WHERE employee_id = 101)` returns a set of values for job title and department, and the main query compares it using the `IN` operator.

### Example 2: Display Orders with the Same Products

```sql
SELECT order_id, product_id, quantity
FROM order_items
WHERE (order_id, product_id) IN (
  SELECT order_id, product_id
  FROM order_items
  WHERE quantity > 5
);
```

**Explanation:**
- This query shows orders with products where the quantity is greater than 5.
- The row subquery `(SELECT order_id, product_id FROM order_items WHERE quantity > 5)` returns a set of order_id and product_id pairs, and the main query filters based on the `IN` condition.

### Example 3: Retrieve Customers with Multiple Orders

```sql
SELECT customer_id, customer_name
FROM customers
WHERE customer_id IN (
  SELECT customer_id
  FROM orders
  GROUP BY customer_id
  HAVING COUNT(order_id) > 1
);
```

**Explanation:**
- This query fetches customers who have placed multiple orders.
- The row subquery `(SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(order_id) > 1)` returns a list of customer_ids with more than one order, and the main query filters based on the `IN` condition.

### Example 4: Get Employees with Higher Salaries in the Same Department

```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees
WHERE (salary, department_id) > (
  SELECT AVG(salary), department_id
  FROM employees
  GROUP BY department_id
  HAVING department_id = employees.department_id
);
```

**Explanation:**
- This query retrieves employees whose salary is higher than the average salary in their respective departments.
- The row subquery `(SELECT AVG(salary), department_id FROM employees GROUP BY department_id HAVING department_id = employees.department_id)` returns the average salary and department_id pairs, and the main query compares them using the `>` operator.

### Example 5: Find Products with Similar Characteristics

```sql
SELECT product_id, product_name, category
FROM products
WHERE (price, weight, color) = (
  SELECT price, weight, color
  FROM products
  WHERE product_id = 101
);
```

**Explanation:**
- This query finds products with similar characteristics (price, weight, and color) as the product with `product_id` 101.
- The row subquery `(SELECT price, weight, color FROM products WHERE product_id = 101)` returns a set of values for the specified product, and the main query compares them using the `=` operator.

## Use cases and examples.

### Use Case 1: Filtering Based on Aggregated Results

**Example: Find Departments with Average Salary Above Company Average**
```sql
SELECT department_id, department_name
FROM departments
WHERE (SELECT AVG(salary) FROM employees WHERE department_id = departments.department_id) > 
      (SELECT AVG(salary) FROM employees);
```

This query retrieves departments where the average salary is above the overall company average salary. Subqueries are used to calculate both the departmental and company-wide average salaries.

### Use Case 2: Checking Existence

**Example: Find Customers with Orders**
```sql
SELECT customer_id, customer_name
FROM customers
WHERE EXISTS (SELECT * FROM orders WHERE orders.customer_id = customers.customer_id);
```

This query selects customers who have placed at least one order. The subquery checks for the existence of orders for each customer.

### Use Case 3: Subqueries in FROM Clause (Derived Tables)

**Example: Find Employees with Salaries Above Department Average**
```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees AS e2 WHERE e2.department_id = employees.department_id);
```

In this example, a subquery is used in the FROM clause to create a derived table (`e2`) that calculates the average salary for each department. The main query then filters employees based on salaries exceeding their department's average.

### Use Case 4: Correlated Subqueries

**Example: Find Employees with Salaries Higher Than Their Managers**
```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees e1
WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.manager_id = e1.employee_id);
```

This query uses a correlated subquery to compare each employee's salary with the average salary of employees managed by the same manager. It selects employees with salaries higher than the average in their manager's group.

### Use Case 5: IN Operator

**Example: Find Products Sold in More Than One Order**
```sql
SELECT product_id, product_name
FROM products
WHERE product_id IN (SELECT product_id FROM order_items GROUP BY product_id HAVING COUNT(DISTINCT order_id) > 1);
```

This query identifies products that have been sold in more than one order. The subquery uses the IN operator with a list of product_ids from order_items where the product appears in multiple orders.

### Use Case 6: Comparisons and Set Operations

**Example: Find Employees with Salaries Higher Than Any Manager**
```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees e1
WHERE salary > ANY (SELECT salary FROM employees e2 WHERE e2.employee_id <> e1.manager_id);
```

This query uses the ANY keyword to compare each employee's salary with the salaries of all managers (excluding their own) in the subquery.

# 4. **Table Subqueries:**
## Overview of table subqueries.
A table subquery, also known as a derived table or inline view, is a subquery that returns a result set that can be treated as a table within the context of the main query. Table subqueries are often used in the FROM clause of a query to provide a dynamic set of data that can be joined, filtered, or manipulated further.

### Syntax of Table Subquery:

The basic syntax of a table subquery in the FROM clause is as follows:

```sql
SELECT column1, column2, ...
FROM (
  SELECT subquery_column1, subquery_column2, ...
  FROM subquery_table
  WHERE subquery_conditions
) AS alias_name;
```

### Key Points about Table Subqueries:

1. **Used in FROM Clause:**
   - Table subqueries are placed in the FROM clause of the main query, providing a virtual table that can be used for further processing.

2. **Result Set as a Table:**
   - The result set of the subquery is treated as a temporary table and can be referenced by an alias.

3. **Flexible Joining:**
   - Table subqueries can be joined with other tables or subqueries in the main query, enabling more complex data manipulations.

4. **Filtering and Aggregation:**
   - Conditions and aggregate functions can be applied to the result set of the table subquery, similar to regular tables.

### Example: Using Table Subquery in a Join Operation

```sql
SELECT e.employee_id, e.employee_name, d.department_name
FROM employees e
JOIN (
  SELECT department_id, department_name
  FROM departments
  WHERE location_id = 1700
) AS d ON e.department_id = d.department_id;
```

In this example:
- The table subquery `(SELECT department_id, department_name FROM departments WHERE location_id = 1700)` provides a dynamic table of departments located in a specific location.
- The main query then joins the employees and the derived department table based on the department_id.

### Use Case: Filtering with Dynamic Criteria

```sql
SELECT order_id, order_date, customer_id
FROM orders
WHERE customer_id IN (
  SELECT customer_id
  FROM customers
  WHERE registration_date > '2022-01-01'
);
```

In this case:
- The table subquery `(SELECT customer_id FROM customers WHERE registration_date > '2022-01-01')` generates a dynamic list of customer_ids based on a specific registration date criterion.
- The main query filters orders based on whether their customer_id is present in the dynamically generated table.

## Examples illustrating the use of table subqueries.

### Example 1: Display Employees and Their Average Salaries by Department

```sql
SELECT e.employee_id, e.employee_name, e.salary, d.department_id, d.avg_salary
FROM employees e
JOIN (
  SELECT department_id, AVG(salary) AS avg_salary
  FROM employees
  GROUP BY department_id
) AS d ON e.department_id = d.department_id;
```

In this example:
- The table subquery `(SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id)` calculates the average salary for each department.
- The main query then joins the employees and the derived department table based on the department_id, displaying each employee along with their department's average salary.

### Example 2: Find Departments with More Than 10 Employees

```sql
SELECT department_id, department_name
FROM departments
WHERE department_id IN (
  SELECT department_id
  FROM employees
  GROUP BY department_id
  HAVING COUNT(employee_id) > 10
);
```

Here:
- The table subquery `(SELECT department_id FROM employees GROUP BY department_id HAVING COUNT(employee_id) > 10)` generates a list of department_ids with more than 10 employees.
- The main query then selects departments based on their presence in the dynamically generated table.

### Example 3: Retrieve Orders with Total Amounts and Customer Details

```sql
SELECT o.order_id, o.order_date, o.total_amount, c.customer_name
FROM orders o
JOIN (
  SELECT order_id, SUM(quantity * unit_price) AS total_amount
  FROM order_items
  GROUP BY order_id
) AS oi ON o.order_id = oi.order_id
JOIN customers c ON o.customer_id = c.customer_id;
```

In this scenario:
- The table subquery `(SELECT order_id, SUM(quantity * unit_price) AS total_amount FROM order_items GROUP BY order_id)` calculates the total amount for each order.
- The main query then joins orders with the derived order_items table based on the order_id and also includes customer details.

### Example 4: Display Products with Highest Prices in Each Category

```sql
SELECT p.product_id, p.product_name, p.price, p.category
FROM products p
JOIN (
  SELECT category, MAX(price) AS max_price
  FROM products
  GROUP BY category
) AS max_prices ON p.category = max_prices.category AND p.price = max_prices.max_price;
```

In this case:
- The table subquery `(SELECT category, MAX(price) AS max_price FROM products GROUP BY category)` determines the maximum price for each product category.
- The main query then joins the products with the derived table of maximum prices, displaying products with the highest price in each category.

# 5. **Subquery Operators:**
## IN operator with subqueries.
The `IN` operator in SQL is used to determine whether a specified value matches any value in a subquery or a list. It is commonly used with subqueries to filter results based on a set of values returned by the subquery. Let's explore some examples illustrating the use of the `IN` operator with subqueries.

### Example 1: Find Customers with Orders

```sql
SELECT customer_id, customer_name
FROM customers
WHERE customer_id IN (SELECT customer_id FROM orders);
```

This query retrieves customers who have placed at least one order. The `IN` operator is used to check if the `customer_id` from the `customers` table exists in the set of `customer_id` values returned by the subquery `(SELECT customer_id FROM orders)`.

### Example 2: Retrieve Products Sold in Multiple Orders

```sql
SELECT product_id, product_name
FROM products
WHERE product_id IN (
  SELECT product_id
  FROM order_items
  GROUP BY product_id
  HAVING COUNT(DISTINCT order_id) > 1
);
```

In this example, the `IN` operator is used to filter products based on whether their `product_id` is present in the set of `product_id` values returned by the subquery. The subquery `(SELECT product_id FROM order_items GROUP BY product_id HAVING COUNT(DISTINCT order_id) > 1)` identifies products sold in more than one order.

### Example 3: Filter Employees with Specific Job Titles

```sql
SELECT employee_id, employee_name, job_title
FROM employees
WHERE job_title IN ('Manager', 'Analyst', 'Developer');
```

This query selects employees with job titles matching any of the specified values ('Manager', 'Analyst', 'Developer'). The `IN` operator is used with a list of values directly in the main query.

### Example 4: Display Orders from Specific Customers

```sql
SELECT order_id, order_date, customer_id
FROM orders
WHERE customer_id IN (
  SELECT customer_id
  FROM customers
  WHERE country = 'USA'
);
```

Here, the `IN` operator is used to filter orders based on whether their `customer_id` is present in the set of `customer_id` values returned by the subquery. The subquery `(SELECT customer_id FROM customers WHERE country = 'USA')` identifies customers from the USA.

### Example 5: Filter Products in a Specific Category

```sql
SELECT product_id, product_name, category
FROM products
WHERE category IN (
  SELECT DISTINCT category
  FROM products
  WHERE price > 100
);
```

This query selects products in a category where the price is greater than 100. The `IN` operator is used with a subquery to obtain a distinct set of categories with prices above the specified threshold.

## EXISTS operator with subqueries.
The `EXISTS` operator in SQL is used to test whether a subquery returns any results. It returns `TRUE` if the subquery returns one or more rows; otherwise, it returns `FALSE`. The `EXISTS` operator is often used with correlated subqueries, where the inner subquery refers to columns from the outer query. Let's explore some examples illustrating the use of the `EXISTS` operator with subqueries.

### Example 1: Find Customers with Orders

```sql
SELECT customer_id, customer_name
FROM customers c
WHERE EXISTS (
  SELECT 1
  FROM orders o
  WHERE o.customer_id = c.customer_id
);
```

In this example:
- The `EXISTS` operator is used to check if there are any rows in the subquery `(SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id)`.
- The main query selects customers where the `EXISTS` condition is `TRUE`, meaning the customer has placed at least one order.

### Example 2: Retrieve Employees with High Salaries

```sql
SELECT employee_id, employee_name, salary
FROM employees e
WHERE EXISTS (
  SELECT 1
  FROM employees
  WHERE salary > 100000
  AND department_id = e.department_id
);
```

Here:
- The `EXISTS` operator checks if there are employees within the same department as the outer query's employee (`e.department_id`) with salaries greater than 100,000.
- The main query selects employees where the `EXISTS` condition is met.

### Example 3: Display Orders with Specific Products

```sql
SELECT order_id, order_date, customer_id
FROM orders o
WHERE EXISTS (
  SELECT 1
  FROM order_items oi
  WHERE oi.order_id = o.order_id
  AND oi.product_id = 'P101'
);
```

In this scenario:
- The `EXISTS` operator checks if there are any rows in the subquery `(SELECT 1 FROM order_items oi WHERE oi.order_id = o.order_id AND oi.product_id = 'P101')`.
- The main query selects orders where the specified product ('P101') is part of the order items.

### Example 4: Filter Products with No Orders

```sql
SELECT product_id, product_name
FROM products p
WHERE NOT EXISTS (
  SELECT 1
  FROM order_items oi
  WHERE oi.product_id = p.product_id
);
```

This query selects products where there are no corresponding entries in the `order_items` table for that product (`NOT EXISTS`). The subquery checks if there are any rows in `order_items` with the specified `product_id`.

### Example 5: Find Departments with Managers

```sql
SELECT department_id, department_name
FROM departments d
WHERE EXISTS (
  SELECT 1
  FROM employees e
  WHERE e.department_id = d.department_id
  AND e.job_title = 'Manager'
);
```

In this example:
- The `EXISTS` operator checks if there are any employees within each department with the job title 'Manager'.
- The main query selects departments where the `EXISTS` condition is met.

## Comparison operators in subqueries.
Comparison operators in subqueries allow you to compare the result of a subquery with a specific value or set of values. These operators include `=`, `<`, `>`, `<=`, `>=`, `<>` (not equal), and others. Let's explore examples of how comparison operators can be used in subqueries.

### Example 1: Equal (=) Operator

#### Find Customers with Orders Placed on a Specific Date
```sql
SELECT customer_id, customer_name
FROM customers
WHERE customer_id = (SELECT customer_id FROM orders WHERE order_date = '2023-01-15');
```

This query retrieves customers who placed orders on a specific date by using the equal (=) operator in the subquery.

### Example 2: Not Equal (<>) Operator

#### Retrieve Products Not Sold in Any Order
```sql
SELECT product_id, product_name
FROM products
WHERE product_id NOT IN (SELECT product_id FROM order_items);
```

This query selects products that have not been sold in any order by using the not equal (`<>`) operator in the subquery.

### Example 3: Greater Than (>) Operator

#### Find Employees with Salaries Higher Than the Average
```sql
SELECT employee_id, employee_name, salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);
```

This query selects employees with salaries higher than the average salary, utilizing the greater than (`>`) operator in the subquery.

### Example 4: Less Than (<) Operator

#### Display Products Priced Lower Than a Threshold
```sql
SELECT product_id, product_name, price
FROM products
WHERE price < (SELECT AVG(price) FROM products);
```

This query retrieves products priced lower than the average price, employing the less than (`<`) operator in the subquery.

### Example 5: Greater Than or Equal To (>=) Operator

#### Find Employees with Salaries Greater Than or Equal to a Threshold
```sql
SELECT employee_id, employee_name, salary
FROM employees
WHERE salary >= (SELECT MAX(salary) FROM employees WHERE department_id = 101);
```

This query selects employees with salaries greater than or equal to the maximum salary in a specific department, using the greater than or equal to (`>=`) operator in the subquery.

### Example 6: Less Than or Equal To (<=) Operator

#### Retrieve Orders with Total Amounts Less Than or Equal to a Limit
```sql
SELECT order_id, order_date, total_amount
FROM orders
WHERE (SELECT SUM(quantity * unit_price) FROM order_items WHERE order_id = orders.order_id) <= 1000;
```

This query retrieves orders with total amounts less than or equal to a specified limit, employing the less than or equal to (`<=`) operator in the subquery.

# 6. **Correlated Subqueries:**
## Understanding correlated subqueries.
A correlated subquery is a type of subquery where the inner query references columns from the outer query. Unlike non-correlated subqueries, which can be executed independently of the outer query, correlated subqueries are dependent on the outer query's results. Each row processed by the outer query can produce a different result in the correlated subquery. This dependency is established through a correlation between the inner and outer queries.

Here's a breakdown of the key aspects of correlated subqueries:

### Structure of a Correlated Subquery:

A correlated subquery typically has the following structure:

```sql
SELECT outer_column1, outer_column2, ...
FROM outer_table o
WHERE condition_operator (SELECT inner_column
                          FROM inner_table i
                          WHERE i.related_column = o.related_column);
```

- The `o.related_column` in the subquery refers to a column in the outer query's table (`outer_table`), creating a correlation.
- The subquery is executed for each row processed by the outer query.

### Characteristics of Correlated Subqueries:

1. **Dependency on Outer Query:**
   - The results of the subquery are dependent on the current row being processed by the outer query.

2. **Evaluation for Each Row:**
   - The subquery is evaluated for each row returned by the outer query.

3. **Use of Correlated Columns:**
   - Columns from the outer query are used in the subquery's conditions, creating a connection between the two.

### Example of a Correlated Subquery:

Let's consider an example where we want to find employees with salaries higher than the average salary in their department:

```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees e_outer
WHERE salary > (
  SELECT AVG(salary)
  FROM employees e_inner
  WHERE e_inner.department_id = e_outer.department_id
);
```

In this example:
- The subquery references `e_outer.department_id`, which is the department of the current row being processed by the outer query.
- For each row in the outer query, the subquery calculates the average salary for that specific department.
- The outer query then selects employees whose salary is greater than the average salary in their respective departments.

### Benefits of Correlated Subqueries:

1. **Flexibility:**
   - Correlated subqueries allow for more dynamic and context-dependent conditions in the subquery.

2. **Fine-Grained Control:**
   - You can apply different conditions for each row based on the values in the outer query.

### Drawbacks of Correlated Subqueries:

1. **Performance Impact:**
   - Correlated subqueries can have a performance impact, as they need to be executed for each row in the outer query.

2. **Complexity:**
   - As the correlation increases, the query's complexity may also increase, making it harder to understand and maintain.

Correlated subqueries are powerful tools when you need to perform row-level operations based on values from the outer query. However, it's essential to use them judiciously and consider potential performance implications.
## Differences between correlated and non-correlated subqueries.
Correlated and non-correlated subqueries are two types of subqueries used in SQL, and they differ primarily in how they interact with the outer query. Here are the key differences between correlated and non-correlated subqueries:

### 1. **Dependency on Outer Query:**

- **Correlated Subqueries:**
  - Correlated subqueries depend on the outer query. The subquery references columns from the outer query, and its results are affected by the current row being processed in the outer query.

- **Non-correlated Subqueries:**
  - Non-correlated subqueries are independent of the outer query. They can be executed independently and do not reference columns from the outer query.

### 2. **Execution Frequency:**

- **Correlated Subqueries:**
  - Executed once for each row processed by the outer query. The subquery is re-evaluated for every row in the outer result set.

- **Non-correlated Subqueries:**
  - Executed once, and the result is applied to the entire outer query. The subquery is processed once, and its result is used in the outer query.

### 3. **Usage of Outer Columns:**

- **Correlated Subqueries:**
  - Correlated subqueries use columns from the outer query in their conditions. These columns create a link or correlation between the inner and outer queries.

- **Non-correlated Subqueries:**
  - Non-correlated subqueries do not reference columns from the outer query. They are standalone queries that provide a constant value or set of values.

### 4. **Independence:**

- **Correlated Subqueries:**
  - Dependent on the current row of the outer query, allowing for context-dependent calculations and comparisons.

- **Non-correlated Subqueries:**
  - Independent of the outer query, making them suitable for providing a constant or aggregate value not tied to specific rows.

### 5. **Performance:**

- **Correlated Subqueries:**
  - May have a performance impact, especially if the subquery involves complex calculations or has to be executed for a large number of rows.

- **Non-correlated Subqueries:**
  - Generally have better performance as they are executed once and their result is used across the entire outer query.

### 6. **Examples:**

- **Correlated Subquery Example:**
  ```sql
  SELECT employee_id, employee_name, salary
  FROM employees e_outer
  WHERE salary > (
    SELECT AVG(salary)
    FROM employees e_inner
    WHERE e_inner.department_id = e_outer.department_id
  );
  ```

- **Non-correlated Subquery Example:**
  ```sql
  SELECT employee_id, employee_name, salary
  FROM employees
  WHERE salary > (SELECT AVG(salary) FROM employees);
  ```

Understanding the differences between correlated and non-correlated subqueries is crucial for choosing the appropriate approach based on the specific requirements of a query. Correlated subqueries provide more context-dependent operations, while non-correlated subqueries are useful for providing constant values or aggregated results.

## Real-world scenarios and examples.
Let's explore some real-world scenarios and examples where correlated and non-correlated subqueries can be applied to solve specific problems.

### Correlated Subquery Example:

#### Scenario: Finding Employees with Salaries Above Department Average

**Problem Statement:**
Find employees whose salaries are higher than the average salary in their respective departments.

**Correlated Subquery:**
```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees e_outer
WHERE salary > (
  SELECT AVG(salary)
  FROM employees e_inner
  WHERE e_inner.department_id = e_outer.department_id
);
```

**Explanation:**
- The correlated subquery is used to calculate the average salary (`AVG(salary)`) for each department (`e_inner.department_id = e_outer.department_id`).
- The outer query then selects employees whose salary is higher than the average salary in their respective departments.

**Real-world Use Case:**
In a company, you might want to identify employees whose salaries stand out compared to their peers within the same department. This could be useful for performance reviews or identifying potential candidates for salary adjustments.

### Non-correlated Subquery Example:

#### Scenario: Retrieving Products with the Highest Price

**Problem Statement:**
Retrieve products with the highest price, regardless of any specific criteria.

**Non-correlated Subquery:**
```sql
SELECT product_id, product_name, price
FROM products
WHERE price = (SELECT MAX(price) FROM products);
```

**Explanation:**
- The non-correlated subquery calculates the maximum price (`MAX(price)`) across all products.
- The outer query selects products where the price matches the maximum price obtained from the subquery.

**Real-world Use Case:**
In an e-commerce system, you might want to display a list of top-priced products on a webpage. The non-correlated subquery helps identify products with the highest prices regardless of any specific category or condition.

# 7. **Nested Subqueries:**
## Nesting subqueries within subqueries.
Nesting subqueries within subqueries, also known as nested subqueries or subquery chaining, involves placing one or more subqueries inside another subquery. This approach allows for more complex and layered data retrieval, filtering, and analysis. Let's explore an example to illustrate the concept:

### Example: Nested Subqueries

#### Scenario: Finding Customers with High Total Purchases

**Problem Statement:**
Find customers who have made total purchases (sum of order amounts) greater than the average total purchases across all customers.

**Nested Subquery:**
```sql
SELECT customer_id, customer_name, total_purchases
FROM customers c
WHERE total_purchases > (
  SELECT AVG(customer_total_purchases)
  FROM (
    SELECT customer_id, SUM(total_amount) AS customer_total_purchases
    FROM orders
    GROUP BY customer_id
  ) AS customer_totals
);
```

**Explanation:**
1. The innermost subquery calculates the total purchases (`SUM(total_amount)`) for each customer (`GROUP BY customer_id`).
2. The middle subquery aliases the result as `customer_totals` and calculates the average total purchases across all customers (`AVG(customer_total_purchases)`).
3. The outer query then selects customers whose total purchases exceed the average calculated in the middle subquery.

**Real-world Use Case:**
In a retail system, this query could help identify customers whose purchasing behavior significantly exceeds the average. This information could be useful for targeted marketing or loyalty program initiatives.

### Considerations for Nested Subqueries:

1. **Readability and Maintenance:**
   - While nested subqueries provide flexibility, it's essential to consider the readability and maintainability of the SQL code. Excessive nesting can make queries harder to understand.

2. **Performance:**
   - Nested subqueries may impact performance, especially if the dataset is large. Each level of nesting involves additional processing.

3. **Optimization:**
   - Use indexes appropriately, and consider alternative approaches like joins or window functions if nested subqueries result in performance issues.

4. **Database Compatibility:**
   - The syntax for nested subqueries may vary slightly between different database systems. Be aware of the specific SQL dialect your database uses.

### Alternative Approach: Join and Aggregate

The same scenario can be approached using a join and aggregate functions, which might improve readability:

```sql
SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_purchases
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.customer_name
HAVING total_purchases > (SELECT AVG(total_amount) FROM orders);
```

This alternative uses a join between the `customers` and `orders` tables and aggregates the total purchases per customer. The `HAVING` clause filters customers based on the average total purchases.

## Limitations and best practices for nested subqueries.
Nested subqueries can be powerful tools in SQL, but they come with limitations and best practices that should be considered to ensure efficient and maintainable queries. Here are some limitations and best practices for nested subqueries:

### Limitations:

1. **Performance Impact:**
   - Excessive use of nested subqueries can impact performance, especially on large datasets. Each level of nesting adds complexity to the query and may result in longer execution times.

2. **Readability:**
   - Excessive nesting can make queries harder to read and understand. It's crucial to balance the need for complexity with the readability of the code.

3. **Database Compatibility:**
   - SQL syntax for nested subqueries may vary slightly between different database systems. Ensure that your queries are compatible with the specific SQL dialect used by your database.

4. **Optimizer Challenges:**
   - Database optimizers may struggle to find the most efficient execution plan for highly nested queries. This can lead to suboptimal performance.

### Best Practices:

1. **Limit Nesting Levels:**
   - Limit the number of nested subqueries to maintain readability. Avoid unnecessary complexity and consider alternative approaches if nesting becomes too deep.

2. **Use Joins When Appropriate:**
   - Instead of relying solely on nested subqueries, consider using JOIN operations for better performance, especially when dealing with multiple tables.

3. **Indexes:**
   - Ensure that relevant columns involved in subqueries are indexed to improve performance. Indexes can significantly impact the execution time of nested queries.

4. **Evaluate Alternatives:**
   - Explore alternative approaches, such as using JOINs, window functions, or common table expressions (CTEs), to achieve the same result without excessive nesting.

5. **Aggregate Functions:**
   - For aggregate calculations, consider using aggregate functions and GROUP BY clauses instead of nested subqueries. This can lead to more readable and optimized queries.

6. **Test and Optimize:**
   - Test the performance of your queries, and use database profiling tools to identify areas for optimization. Understand the execution plan generated by the database optimizer.

7. **Consider Subquery Placement:**
   - Consider whether a subquery is best placed in the SELECT, FROM, WHERE, or HAVING clause based on its purpose. Different placements can have different performance implications.

8. **Understand Data Distribution:**
   - Have a good understanding of the data distribution and characteristics of the tables involved in subqueries. This understanding can help optimize the query.

9. **Document and Comment:**
   - Document your nested subqueries and add comments to explain their purpose. This is crucial for the benefit of both current and future developers working with the code.

10. **Think About Maintainability:**
    - Consider the long-term maintainability of your queries. Choose an approach that strikes a balance between performance and ease of understanding for those who will work with the code later.

## Examples showcasing nested subqueries.
Let's explore a few examples showcasing the use of nested subqueries in SQL. These examples demonstrate scenarios where nesting subqueries provides a solution to specific problems.

### Example 1: Finding Customers with the Highest Purchase Amount

**Scenario:**
Find customers who made purchases with the highest total amount.

**Nested Subquery:**
```sql
SELECT customer_id, customer_name, total_purchase_amount
FROM customers c
WHERE total_purchase_amount = (
  SELECT MAX(total_amount)
  FROM orders
  WHERE customer_id = c.customer_id
);
```

**Explanation:**
- The nested subquery calculates the maximum total amount for each customer (`MAX(total_amount)`).
- The outer query selects customers whose total purchase amount matches the maximum amount obtained from the subquery.

### Example 2: Identifying Products with Prices Above Average

**Scenario:**
Retrieve products with prices higher than the average price.

**Nested Subquery:**
```sql
SELECT product_id, product_name, price
FROM products p
WHERE price > (
  SELECT AVG(price)
  FROM products
);
```

**Explanation:**
- The nested subquery calculates the average price of all products (`AVG(price)`).
- The outer query selects products whose individual prices are higher than the calculated average.

### Example 3: Finding Departments with More Than One Employee

**Scenario:**
Identify departments with more than one employee.

**Nested Subquery:**
```sql
SELECT department_id, department_name
FROM departments d
WHERE (
  SELECT COUNT(*)
  FROM employees
  WHERE department_id = d.department_id
) > 1;
```

**Explanation:**
- The nested subquery calculates the count of employees in each department (`COUNT(*)`).
- The outer query selects departments where the count of employees is greater than one, indicating more than one employee in the department.

### Example 4: Finding Customers with Orders Placed on the Latest Date

**Scenario:**
Find customers who placed orders on the latest date.

**Nested Subquery:**
```sql
SELECT customer_id, customer_name
FROM customers c
WHERE (
  SELECT MAX(order_date)
  FROM orders
  WHERE customer_id = c.customer_id
) = (
  SELECT MAX(order_date)
  FROM orders
);
```

**Explanation:**
- The nested subquery calculates the maximum order date for each customer (`MAX(order_date)`).
- The outer query selects customers whose maximum order date matches the overall maximum order date.


# 8. **Subqueries in Different Clauses:**
Certainly! Let's explore examples showcasing the use of subqueries in different clauses of a SQL query: WHERE, SELECT, FROM, and HAVING.

## 1. Using Subqueries in WHERE Clauses:

#### Scenario: Finding Employees with Salaries Above Department Average

```sql
SELECT employee_id, employee_name, salary, department_id
FROM employees e
WHERE salary > (
  SELECT AVG(salary)
  FROM employees
  WHERE department_id = e.department_id
);
```

**Explanation:**
- The subquery in the WHERE clause calculates the average salary for each department (`AVG(salary)`).
- The main query selects employees whose salary is higher than the average salary in their respective departments.

## 2. Incorporating Subqueries in SELECT Clauses:

#### Scenario: Displaying Product Names with the Number of Orders

```sql
SELECT product_name,
       (SELECT COUNT(*)
        FROM order_items oi
        WHERE oi.product_id = p.product_id) AS order_count
FROM products p;
```

**Explanation:**
- The subquery in the SELECT clause counts the number of orders for each product (`COUNT(*)`).
- The main query selects product names along with the corresponding count of orders.

## 3. Utilizing Subqueries in FROM Clauses:

#### Scenario: Finding Departments with More Than Two Employees

```sql
SELECT d.department_id, d.department_name, employee_count
FROM departments d
JOIN (
  SELECT department_id, COUNT(*) AS employee_count
  FROM employees
  GROUP BY department_id
  HAVING COUNT(*) > 2
) e ON d.department_id = e.department_id;
```

**Explanation:**
- The subquery in the FROM clause calculates the count of employees per department (`COUNT(*)`) and filters for departments with more than two employees (`HAVING COUNT(*) > 2`).
- The main query joins this result with the departments table to retrieve relevant information.

## 4. Demonstrating Subqueries in HAVING Clauses:

#### Scenario: Displaying Departments with Average Salary Above Company Average

```sql
SELECT department_id, AVG(salary) AS avg_department_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) > (
  SELECT AVG(salary)
  FROM employees
);
```

**Explanation:**
- The subquery in the HAVING clause calculates the overall average salary of all employees (`AVG(salary)`).
- The main query groups the data by department and selects departments with an average salary above the company average.


# 9. **Aggregated Subqueries:**

## 1. Aggregating Results Within Subqueries:

#### Scenario: Finding Customers with the Highest Total Purchases

```sql
SELECT customer_id, customer_name, total_purchases
FROM customers c
WHERE total_purchases = (
  SELECT SUM(total_amount)
  FROM orders
  WHERE customer_id = c.customer_id
);
```

**Explanation:**
- The subquery calculates the total purchases (`SUM(total_amount)`) for each customer.
- The main query selects customers whose total purchases match the maximum total amount obtained from the subquery.

## 2. Utilizing GROUP BY and HAVING Clauses with Subqueries:

#### Scenario: Identifying Departments with Average Salary Above Company Average

```sql
SELECT department_id, AVG(salary) AS avg_department_salary
FROM employees
GROUP BY department_id
HAVING AVG(salary) > (
  SELECT AVG(salary)
  FROM employees
);
```

**Explanation:**
- The subquery calculates the overall average salary of all employees (`AVG(salary)`).
- The main query groups the data by department and selects departments with an average salary above the company average.

## 3. Real-world Scenarios and Use Cases:

#### Scenario: Finding Products with Quantity Sold Above Average

```sql
SELECT product_id, product_name, SUM(quantity) AS total_quantity_sold
FROM order_items oi
GROUP BY product_id, product_name
HAVING SUM(quantity) > (
  SELECT AVG(quantity)
  FROM order_items
);
```

**Explanation:**
- The subquery calculates the average quantity sold (`AVG(quantity)`) across all products.
- The main query groups the data by product and selects products with a total quantity sold above the average.

#### Scenario: Identifying Customers with the Most Orders

```sql
SELECT customer_id, customer_name, COUNT(*) AS order_count
FROM orders
GROUP BY customer_id, customer_name
HAVING COUNT(*) = (
  SELECT MAX(order_count)
  FROM (
    SELECT COUNT(*) AS order_count
    FROM orders
    GROUP BY customer_id
  ) AS customer_orders
);
```

**Explanation:**
- The inner subquery calculates the order count for each customer (`COUNT(*)`).
- The outer subquery finds the maximum order count across all customers.
- The main query groups the data by customer and selects customers with the maximum order count.


# 10. **Combining Subqueries with Joins:**
Certainly! Integrating subqueries with INNER and OUTER JOINs is a powerful technique that allows you to combine data from multiple tables while leveraging subqueries for additional filtering or calculations. Let's explore practical examples illustrating the combination of subqueries and joins:

## 1. Using Subqueries with INNER JOIN:

#### Scenario: Finding Customers and Their Most Recent Order Date

```sql
SELECT c.customer_id, c.customer_name, o.most_recent_order_date
FROM customers c
INNER JOIN (
  SELECT customer_id, MAX(order_date) AS most_recent_order_date
  FROM orders
  GROUP BY customer_id
) o ON c.customer_id = o.customer_id;
```

**Explanation:**
- The subquery calculates the most recent order date for each customer (`MAX(order_date)`).
- The main query performs an INNER JOIN between the `customers` and the subquery results on the `customer_id` to get customers and their most recent order date.

## 2. Using Subqueries with LEFT OUTER JOIN:

#### Scenario: Displaying Products and Their Average Ratings (Including Products with No Ratings)

```sql
SELECT p.product_id, p.product_name, COALESCE(AVG(r.rating), 0) AS avg_rating
FROM products p
LEFT OUTER JOIN ratings r ON p.product_id = r.product_id
GROUP BY p.product_id, p.product_name;
```

**Explanation:**
- The subquery calculates the average rating for each product (`AVG(rating)`).
- The main query performs a LEFT OUTER JOIN between the `products` and `ratings` tables on the `product_id` to get products and their average ratings. The COALESCE function is used to handle cases where a product has no ratings.

## 3. Using Subqueries with Correlated INNER JOIN:

#### Scenario: Finding Employees with Salaries Above Department Average

```sql
SELECT e.employee_id, e.employee_name, e.salary, e.department_id
FROM employees e
INNER JOIN (
  SELECT department_id, AVG(salary) AS avg_department_salary
  FROM employees
  GROUP BY department_id
) d ON e.department_id = d.department_id
WHERE e.salary > d.avg_department_salary;
```

**Explanation:**
- The subquery calculates the average salary for each department (`AVG(salary)`).
- The main query performs an INNER JOIN between the `employees` and the subquery results on the `department_id` to get employees and their department's average salary. The WHERE clause filters employees with salaries above their department average.

# 11. **Common Table Expressions (CTEs) with Subqueries:**
## Introduction to CTEs.
CTE stands for Common Table Expression, and it is a named temporary result set in SQL. CTEs were introduced in SQL Server 2005 and are part of the SQL standard. They allow you to define a query that can be referenced within another query, providing a more readable and modular way to structure complex SQL statements.

Key features of CTEs include:

1. **Readability:** CTEs enhance the readability of complex queries by breaking them into modular, named parts.

2. **Reuse:** Once defined, a CTE can be referenced multiple times within the same query, making it reusable.

3. **Recursive Queries:** CTEs can be used to create recursive queries, which is useful for hierarchical data structures.

### Basic Syntax of CTE:

```sql
WITH cte_name (column1, column2, ...) AS (
  -- CTE query definition
  SELECT column1, column2, ...
  FROM some_table
  WHERE some_condition
)
-- Main query using the CTE
SELECT *
FROM cte_name;
```

### Example of a Simple CTE:

```sql
-- Define a CTE named "EmployeeCTE"
WITH EmployeeCTE AS (
  SELECT EmployeeID, FirstName, LastName, Salary
  FROM Employees
  WHERE DepartmentID = 1
)
-- Use the CTE in the main query
SELECT *
FROM EmployeeCTE;
```

In this example, the CTE named "EmployeeCTE" selects employees from the "Employees" table who belong to the department with ID 1. The main query then selects all columns from the CTE.

### Recursive CTE Example:

```sql
-- Define a recursive CTE named "HierarchyCTE"
WITH HierarchyCTE AS (
  SELECT EmployeeID, ManagerID, FirstName, LastName
  FROM Employees
  WHERE ManagerID IS NULL -- Anchor member (top-level managers)
  UNION ALL
  SELECT e.EmployeeID, e.ManagerID, e.FirstName, e.LastName
  FROM Employees e
  JOIN HierarchyCTE h ON e.ManagerID = h.EmployeeID -- Recursive member
)
-- Use the recursive CTE in the main query
SELECT *
FROM HierarchyCTE;
```

In this recursive CTE example, the CTE named "HierarchyCTE" is used to represent a hierarchical employee structure. The anchor member selects top-level managers (those with no manager), and the recursive member joins employees to their managers. The main query then selects all columns from the recursive CTE.

## Using CTEs in conjunction with subqueries.
Common Table Expressions (CTEs) and subqueries serve different purposes in SQL, but they can be used together in certain scenarios to create more readable and modular queries. Let's explore an example where CTEs are used in conjunction with subqueries:

### Example: Retrieving Employees and Their Departments

Consider a scenario where you want to retrieve information about employees along with the details of their respective departments. You can use a CTE to define the structure of the final result set and a subquery within the CTE to obtain additional information.

```sql
-- Define a CTE named "EmployeeDetailsCTE"
WITH EmployeeDetailsCTE AS (
  -- Subquery to retrieve employee details and department information
  SELECT 
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    e.Salary,
    d.DepartmentID,
    d.DepartmentName
  FROM 
    Employees e
    JOIN Departments d ON e.DepartmentID = d.DepartmentID
)
-- Main query using the CTE
SELECT *
FROM EmployeeDetailsCTE;
```

In this example:

- The CTE named "EmployeeDetailsCTE" uses a subquery to join the "Employees" and "Departments" tables to retrieve details such as employee name, salary, and department information.

- The main query then selects all columns from the CTE, providing a clean and readable way to express the logic.

This approach is beneficial when the subquery logic is complex or when you want to encapsulate a specific data retrieval pattern. It makes the main query more focused on selecting and filtering data, while the CTE handles the data preparation.

### Example: Using CTE and Subquery with Aggregation

```sql
-- Define a CTE named "DepartmentAverageSalaryCTE"
WITH DepartmentAverageSalaryCTE AS (
  -- Subquery to calculate average salary for each department
  SELECT
    DepartmentID,
    AVG(Salary) AS AvgDepartmentSalary
  FROM
    Employees
  GROUP BY
    DepartmentID
)
-- Main query using the CTE and a subquery
SELECT
  e.EmployeeID,
  e.FirstName,
  e.LastName,
  e.Salary,
  d.DepartmentID,
  d.DepartmentName,
  d.AvgDepartmentSalary
FROM
  Employees e
  JOIN Departments d ON e.DepartmentID = d.DepartmentID
  JOIN (
    -- Subquery to reference the CTE and retrieve average department salary
    SELECT
      DepartmentID,
      AvgDepartmentSalary
    FROM
      DepartmentAverageSalaryCTE
  ) cte ON d.DepartmentID = cte.DepartmentID;
```

In this example, the CTE "DepartmentAverageSalaryCTE" calculates the average salary for each department. The main query then joins the "Employees" and "Departments" tables and incorporates the CTE within a subquery to retrieve the average department salary.

## Benefits and best practices.
Using Common Table Expressions (CTEs) in SQL comes with several benefits and best practices that contribute to writing more maintainable, readable, and efficient queries:

### Benefits:

1. **Readability:**
   - CTEs enhance query readability by allowing you to break down complex queries into modular parts with meaningful names.

2. **Code Reusability:**
   - Once defined, a CTE can be referenced multiple times within the same query, avoiding redundancy and promoting code reuse.

3. **Modularity:**
   - CTEs provide a modular structure to SQL queries, making it easier to understand and maintain, especially for queries with multiple levels of nesting.

4. **Recursive Queries:**
   - CTEs support recursive queries, allowing you to work with hierarchical or recursive data structures.

5. **Improved Debugging:**
   - Breaking down a query into CTEs can aid in debugging by allowing you to examine intermediate results at each CTE step.

6. **Performance Optimization:**
   - In some cases, the use of CTEs can lead to optimized execution plans by providing the database optimizer with clearer insights into query intentions.

7. **Self-Documenting Queries:**
   - CTEs contribute to self-documenting queries by encapsulating logic in named sections, making it easier for others (or yourself) to understand the purpose of each part of the query.

### Best Practices:

1. **Use CTEs for Readability:**
   - Employ CTEs primarily for enhancing query readability. If a query is simple and straightforward, using a CTE might be unnecessary.

2. **Avoid Excessive Nesting:**
   - While CTEs promote modularity, avoid excessive nesting of CTEs within CTEs. This can lead to reduced readability and increased complexity.

3. **Optimize for Reusability:**
   - If you find that a particular CTE could be reused in multiple queries, design it with reusability in mind.

4. **Test and Analyze Performance:**
   - Test the performance of queries with and without CTEs. While CTEs can improve performance in some cases, they might not always be the best choice, and the impact on performance should be evaluated.

5. **Understand Recursive CTEs:**
   - If using recursive CTEs, make sure to have a clear understanding of the hierarchical data structure and how recursion is defined.

6. **Consider Indexing:**
   - Ensure that the columns used in JOIN or WHERE conditions within CTEs are properly indexed to optimize performance.

7. **Use CTEs with Joins:**
   - CTEs can be effectively used with JOIN operations to improve query organization and readability.

8. **Document CTE Purpose:**
   - Provide comments or documentation explaining the purpose of each CTE, especially if the query logic is intricate.

9. **Be Mindful of Database Compatibility:**
   - Be aware of the specific SQL dialect your database system supports, as there might be variations in CTE syntax.

10. **Follow Consistent Naming Conventions:**
    - Adopt consistent and meaningful names for CTEs to enhance code maintainability.

# 12. **Advanced Subquery Techniques:**
## Window functions and subqueries.
Window functions and subqueries are two distinct features in SQL, each serving specific purposes. However, they can be used in conjunction to solve complex analytical problems. Let's explore how window functions and subqueries can be combined:

### 1. Using Window Functions in Subqueries:

#### Scenario: Ranking Departments by Average Salary

Consider a scenario where you want to retrieve departments along with their average salary and the rank of each department based on this average. You can use a window function within a subquery to achieve this.

```sql
SELECT
  DepartmentID,
  DepartmentName,
  AvgDepartmentSalary,
  RANK() OVER (ORDER BY AvgDepartmentSalary DESC) AS DepartmentRank
FROM (
  SELECT
    e.DepartmentID,
    d.DepartmentName,
    AVG(e.Salary) OVER (PARTITION BY e.DepartmentID) AS AvgDepartmentSalary
  FROM
    Employees e
    JOIN Departments d ON e.DepartmentID = d.DepartmentID
) SubqueryAlias;
```

**Explanation:**
- The subquery calculates the average salary for each department using a window function (`AVG(e.Salary) OVER (PARTITION BY e.DepartmentID)`).
- The main query then selects the department details along with the calculated average salary and uses the `RANK()` window function to determine the rank based on average salary.

### 2. Using Subqueries with Window Function Results:

#### Scenario: Selecting Employees with Salaries Above Department Average

In this scenario, you want to retrieve employees with salaries above the average salary for their respective departments. A subquery is used to calculate the average salary by department using a window function.

```sql
SELECT
  EmployeeID,
  FirstName,
  LastName,
  Salary,
  DepartmentID,
  AVG(Salary) OVER (PARTITION BY DepartmentID) AS AvgDepartmentSalary
FROM
  Employees e
WHERE
  Salary > (
    SELECT
      AVG(Salary) OVER (PARTITION BY DepartmentID)
    FROM
      Employees
    WHERE
      DepartmentID = e.DepartmentID
  );
```

**Explanation:**
- The subquery calculates the average salary for each department using a window function (`AVG(Salary) OVER (PARTITION BY DepartmentID)`).
- The main query selects employee details and includes a filter to retain only those employees whose salary is above the calculated average salary for their respective departments.

## Recursive subqueries.
Recursive subqueries are a special type of subquery that references the same table in its FROM and WHERE clauses. Recursive subqueries are typically used to query hierarchical or tree-like structures, such as organizational charts or bill-of-materials relationships. The recursive nature allows the subquery to refer back to its own result set during processing.

Here's an example of a recursive subquery using a common scenario of an employee-manager hierarchy:

### Example: Recursive Subquery for Employee Hierarchy

Consider a table named `Employees` with columns `EmployeeID` and `ManagerID`, where `ManagerID` refers to the `EmployeeID` of the manager. The goal is to retrieve the hierarchy of employees for a specific manager.

```sql
WITH RecursiveEmployeeCTE AS (
  SELECT
    EmployeeID,
    FirstName,
    LastName,
    ManagerID,
    1 AS Level
  FROM
    Employees
  WHERE
    ManagerID IS NULL  -- Anchor member (top-level managers)
  
  UNION ALL
  
  SELECT
    e.EmployeeID,
    e.FirstName,
    e.LastName,
    e.ManagerID,
    rec.Level + 1
  FROM
    Employees e
    INNER JOIN RecursiveEmployeeCTE rec ON e.ManagerID = rec.EmployeeID  -- Recursive member
)
SELECT
  EmployeeID,
  FirstName,
  LastName,
  ManagerID,
  Level
FROM
  RecursiveEmployeeCTE;
```

**Explanation:**
- The recursive subquery, defined as `RecursiveEmployeeCTE`, has two parts: the anchor member (top-level managers) and the recursive member.
- The anchor member selects employees with `ManagerID` set to `NULL`.
- The recursive member joins the `Employees` table with the recursive CTE (`RecursiveEmployeeCTE`) on the condition that the manager ID in the employee table matches the employee ID in the CTE. This creates a linkage between employees and their managers, and the `Level` column is incremented for each recursion.
- The final query selects all columns from the recursive CTE.

This example retrieves the entire employee hierarchy, including the top-level managers, their direct reports, and subsequent levels of employees.

### Use Cases for Recursive Subqueries:

1. **Employee Hierarchies:** Displaying the reporting structure within an organization.

2. **Bill of Materials:** Representing the components and subcomponents in a manufacturing process.

3. **Organizational Charts:** Visualizing the hierarchy of positions in an organization.

4. **Comments and Replies:** Modeling threaded discussions where replies refer back to the original comment.

## Advanced use cases and examples.
Advanced use cases of SQL often involve combining various features, including subqueries, window functions, recursive queries, and other advanced techniques. Let's explore a couple of advanced scenarios and examples:

### 1. Analyzing Time Series Data with Window Functions:

Consider a scenario where you have a table `Sales` with columns `Date` and `Revenue`. You want to calculate the rolling average revenue over a specific window of time.

```sql
SELECT
  Date,
  Revenue,
  AVG(Revenue) OVER (ORDER BY Date ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS RollingAverage
FROM
  Sales;
```

**Explanation:**
- This query uses a window function (`AVG() OVER ...`) to calculate the rolling average of `Revenue` over a window of the previous three rows and the current row based on the `Date` column.

### 2. Recursive Subquery for Pathfinding:

Consider a scenario where you have a table `Edges` representing a graph with columns `SourceNode` and `DestinationNode`. You want to find all paths from a given source node to a destination node in the graph.

```sql
WITH RECURSIVE PathCTE AS (
  SELECT
    SourceNode,
    DestinationNode,
    CAST(SourceNode AS VARCHAR(255)) AS Path
  FROM
    Edges
  WHERE
    SourceNode = 'A'
  
  UNION ALL
  
  SELECT
    e.SourceNode,
    e.DestinationNode,
    p.Path || ' -> ' || e.DestinationNode
  FROM
    Edges e
    JOIN PathCTE p ON e.SourceNode = p.DestinationNode
)
SELECT
  SourceNode,
  DestinationNode,
  Path
FROM
  PathCTE;
```

**Explanation:**
- This recursive subquery finds all paths from the source node 'A' to other nodes in the graph.
- The `PathCTE` common table expression (CTE) has an anchor member that selects the initial edges where `SourceNode` is 'A'.
- The recursive member then joins the `Edges` table with the CTE on the condition that the source node in the edge matches the destination node in the CTE. It concatenates the current path with the destination node.

### 3. Analyzing User Behavior with LAG and LEAD Window Functions:

Consider a scenario where you have a table `UserActivity` with columns `UserID`, `Timestamp`, and `PageVisited`. You want to identify the previous and next pages visited by each user based on the timestamp.

```sql
SELECT
  UserID,
  Timestamp,
  PageVisited,
  LAG(PageVisited) OVER (PARTITION BY UserID ORDER BY Timestamp) AS PreviousPage,
  LEAD(PageVisited) OVER (PARTITION BY UserID ORDER BY Timestamp) AS NextPage
FROM
  UserActivity;
```

**Explanation:**
- This query uses the window functions `LAG()` and `LEAD()` to retrieve the previous and next pages visited by each user based on the timestamp.
- The `PARTITION BY UserID` ensures that the calculations are performed separately for each user.


# 13. **Subqueries and Transactions:**
Incorporating subqueries into transactions involves using subqueries within SQL transactions to perform multiple operations as a single unit of work. Transactions ensure that a series of SQL statements are executed atomically, meaning either all of them succeed or none of them do. Subqueries can be a part of these transactions, contributing to a broader set of operations.

## Basic Transaction Structure:

```sql
BEGIN TRANSACTION;

-- SQL statements and subqueries go here

COMMIT; -- or ROLLBACK; in case of an error or undesired state
```

### Example: Updating Two Tables in a Transaction:

Consider a scenario where you want to transfer funds from one account to another and update both the `Accounts` and `Transactions` tables in a transaction.

```sql
BEGIN TRANSACTION;

-- Step 1: Deduct amount from source account
UPDATE Accounts
SET Balance = Balance - 100
WHERE AccountNumber = 'SourceAccount';

-- Step 2: Add amount to destination account
UPDATE Accounts
SET Balance = Balance + 100
WHERE AccountNumber = 'DestinationAccount';

-- Step 3: Record the transaction in the Transactions table
INSERT INTO Transactions (FromAccount, ToAccount, Amount)
VALUES ('SourceAccount', 'DestinationAccount', 100);

COMMIT; -- If everything is successful
-- or ROLLBACK; in case of an error or undesired state
```

**Explanation:**
- The `BEGIN TRANSACTION` initiates the transaction.
- Subsequent SQL statements, including subqueries, are executed within the transaction.
- `COMMIT` finalizes the transaction, making all changes permanent. If an error occurs, `ROLLBACK` can be used to undo the changes made during the transaction.

## Transactional Considerations:

1. **ACID Properties:**
   - Transactions should adhere to ACID properties (Atomicity, Consistency, Isolation, Durability) to ensure reliability and integrity.

2. **Error Handling:**
   - Use proper error handling mechanisms within transactions. If an error occurs, the transaction can be rolled back to maintain a consistent state.

3. **Isolation Levels:**
   - Understand and set the appropriate isolation level for your transactions to control the visibility of changes made by other transactions.

4. **Concurrency Control:**
   - Manage concurrent access to data within transactions to prevent conflicts and ensure data consistency.

5. **Nested Transactions (if supported):**
   - Some database systems support nested transactions. Understand the behavior and limitations if you are dealing with nested transactions.

6. **Testing and Validation:**
   - Thoroughly test transactions to ensure they perform as expected. Validate data changes after transactions to confirm their accuracy.

## Handling Atomic Operations with Subqueries:

- **Inserting Records with Subqueries:**
  ```sql
  BEGIN TRANSACTION;

  INSERT INTO Orders (CustomerID, OrderDate)
  VALUES (
    (SELECT CustomerID FROM Customers WHERE CustomerName = 'John Doe'),
    '2024-02-14'
  );

  COMMIT;
  ```

- **Deleting Records with Subqueries:**
  ```sql
  BEGIN TRANSACTION;

  DELETE FROM Employees
  WHERE DepartmentID = (SELECT DepartmentID FROM Departments WHERE DepartmentName = 'Closed Department');

  COMMIT;
  ```

- **Updating Records with Subqueries:**
  ```sql
  BEGIN TRANSACTION;

  UPDATE Products
  SET Price = Price * 1.1
  WHERE CategoryID = (SELECT CategoryID FROM Categories WHERE CategoryName = 'Electronics');

  COMMIT;
  ```
